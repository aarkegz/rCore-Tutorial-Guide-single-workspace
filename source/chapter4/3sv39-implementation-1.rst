实现 SV39 多级页表机制（上）
========================================================

本节导读
------------------------------------------------------

本节我们将介绍 RISC-V 的 SV39 分页机制，以及在代码框架中如何使用相关的数据结构。由于内容较多，分成两个小节讲解。

在开始之前，让我们先回答一个问题：**为什么叫 SV39？**

- **SV** = Supervisor Virtual address（S 态虚拟地址）
- **39** = 虚拟地址有效位数为 39 位


从物理地址到虚拟地址
------------------------------------------------------

没有分页时的内存访问
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在第三章中，CPU 执行 ``ld a0, 0(a1)`` 指令时：

1. 从 ``a1`` 寄存器读取地址值，假设是 ``0x80400000``
2. 直接将这个值作为物理地址访问内存
3. 将读取的数据写入 ``a0`` 寄存器

这种模式下，程序直接操作物理地址，没有任何地址转换。


启用分页后的内存访问
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

启用 SV39 分页后，同样的指令执行流程变为：

1. 从 ``a1`` 寄存器读取地址值 ``0x80400000``（这是一个 **虚拟地址**）
2. MMU（内存管理单元）根据 ``satp`` 寄存器找到页表
3. MMU 遍历页表，将虚拟地址转换为物理地址（例如 ``0x81234000``）
4. 使用转换后的物理地址访问内存
5. 将读取的数据写入 ``a0`` 寄存器

.. code-block:: text

    虚拟地址                              物理地址
    0x80400000  ───→  [MMU + 页表]  ───→  0x81234000  ───→  内存
                          ↑
                        satp


satp 寄存器
------------------------------------------------------

``satp``（Supervisor Address Translation and Protection）是控制分页的关键 CSR 寄存器。


satp 的结构（64 位）
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: text

    63      60 59        44 43                                    0
    +----------+------------+-------------------------------------+
    |   MODE   |    ASID    |                 PPN                 |
    +----------+------------+-------------------------------------+
       4 位       16 位                      44 位

- **MODE**（4 位）：分页模式

  - ``0``：不分页，地址直接作为物理地址
  - ``8``：SV39 模式，39 位虚拟地址
  - ``9``：SV48 模式，48 位虚拟地址（本章不使用）

- **ASID**（16 位）：地址空间标识符，用于 TLB 优化（本章设为 0）
- **PPN**（44 位）：页表根节点的物理页号


启用分页
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 ``ch4/src/main.rs`` 的 ``kernel_space()`` 函数中：

.. code-block:: rust

    // 设置 satp 寄存器，启用 SV39 分页
    // Mode=8 表示 SV39，space.root_ppn().val() 是页表根节点的物理页号
    unsafe { satp::set(satp::Mode::Sv39, 0, space.root_ppn().val()) };

这行代码执行后，所有 S/U 特权级的内存访问都会经过 MMU 地址转换。


虚拟地址与物理地址
------------------------------------------------------

地址的组成
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SV39 模式下的地址分为两部分：

.. code-block:: text

    虚拟地址（64 位，但只有低 39 位有效）：
    63        39 38                   12 11            0
    +-----------+------------------------+--------------+
    |  保留位   |        VPN (27位)      | 页内偏移(12位)|
    +-----------+------------------------+--------------+
     必须与第38位相同      虚拟页号          偏移量

.. code-block:: text

    物理地址（56 位）：
    55                              12 11            0
    +---------------------------------+--------------+
    |          PPN (44位)             | 页内偏移(12位)|
    +---------------------------------+--------------+
              物理页号                    偏移量


为什么页内偏移是 12 位？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 一页大小 = 4KB = 4096 字节 = 2^12 字节
- 因此需要 12 位来寻址页内的每个字节
- 虚拟地址和物理地址的低 12 位（页内偏移）在转换前后保持不变


关于虚拟地址的 64 位与 39 位
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

虽然 RISC-V 64 位架构的地址寄存器是 64 位，但 SV39 只使用低 39 位。规定：

- 虚拟地址的 ``[63:39]`` 这 25 位必须与第 38 位相同
- 如果第 38 位是 0，则高位全为 0（低地址空间）
- 如果第 38 位是 1，则高位全为 1（高地址空间）

这意味着只有两段地址是合法的：

- ``0x0000_0000_0000_0000`` ~ ``0x0000_003F_FFFF_FFFF``（低 256GB）
- ``0xFFFF_FFC0_0000_0000`` ~ ``0xFFFF_FFFF_FFFF_FFFF``（高 256GB）


地址转换过程
------------------------------------------------------

三级页表结构
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SV39 使用三级页表，虚拟页号（VPN）被分成三部分：

.. code-block:: text

    虚拟地址：
    +-------+-------+-------+-----------+
    | VPN[2]| VPN[1]| VPN[0]| 页内偏移  |
    +-------+-------+-------+-----------+
      9位     9位     9位      12位

每一级页表包含 512 个页表项（2^9 = 512），每个页表项 8 字节，正好一页（512 × 8 = 4096）。


地址转换的步骤
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1. 从 ``satp.PPN`` 找到一级页表（根页表）的物理地址
2. 用 ``VPN[2]`` 作为索引，在一级页表中找到对应的页表项
3. 从页表项中取出二级页表的物理页号
4. 用 ``VPN[1]`` 作为索引，在二级页表中找到对应的页表项
5. 从页表项中取出三级页表的物理页号
6. 用 ``VPN[0]`` 作为索引，在三级页表中找到对应的页表项
7. 从页表项中取出物理页号（PPN），与页内偏移拼接得到物理地址

.. code-block:: text

             +--------+
      satp ──→| 一级页表 |
             +--------+
                  │ VPN[2]
                  ↓
             +--------+
             | 二级页表 |
             +--------+
                  │ VPN[1]
                  ↓
             +--------+
             | 三级页表 |
             +--------+
                  │ VPN[0]
                  ↓
             +--------+
             |  PPN   | ─→ 物理地址 = PPN << 12 | 页内偏移
             +--------+


页表项（PTE）
------------------------------------------------------

页表项的结构
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

每个页表项占 8 字节（64 位）：

.. code-block:: text

    63      54 53                   10 9   8 7 6 5 4 3 2 1 0
    +----------+----------------------+-----+-+-+-+-+-+-+-+-+
    |  保留    |         PPN          |RSW  |D|A|G|U|X|W|R|V|
    +----------+----------------------+-----+-+-+-+-+-+-+-+-+
       10位            44位            2位  标志位（8位）


标志位含义
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. list-table::
   :header-rows: 1

   * - 标志位
     - 名称
     - 含义
   * - V
     - Valid
     - 页表项是否有效
   * - R
     - Read
     - 是否可读
   * - W
     - Write
     - 是否可写
   * - X
     - Execute
     - 是否可执行
   * - U
     - User
     - U 模式是否可访问
   * - G
     - Global
     - 全局映射（本章不使用）
   * - A
     - Accessed
     - 是否被访问过
   * - D
     - Dirty
     - 是否被修改过

**重要规则**：

- 当 ``V=0`` 时，该页表项无效，访问会触发页错误
- 当 ``V=1`` 且 ``R=W=X=0`` 时，该页表项指向下一级页表
- 当 ``V=1`` 且 ``R/W/X`` 至少有一个为 1 时，这是一个叶节点，包含物理页号


在代码中设置标志位
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在 ``ch4/src/main.rs`` 中，我们使用字符串来设置标志位：

.. code-block:: rust

    // 内核代码段：可执行、可读
    VmFlags::build_from_str("X_RV")   // X=1, W=0, R=1, V=1

    // 只读数据段：只读
    VmFlags::build_from_str("__RV")   // X=0, W=0, R=1, V=1

    // 数据段：可读写
    VmFlags::build_from_str("_WRV")   // X=0, W=1, R=1, V=1

    // 用户程序代码：用户态可执行、可读
    VmFlags::build_from_str("UX_RV")  // U=1, X=1, W=0, R=1, V=1


代码框架中的数据结构
------------------------------------------------------

地址和页号类型
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``page_table`` crate 提供了类型安全的地址抽象：

.. code-block:: rust

    // 虚拟地址
    VAddr<Sv39>::new(0x1000)

    // 物理页号
    PPN<Sv39>::new(0x80200)

    // 虚拟页号
    VPN<Sv39>::new(0x1)

这些类型提供了常用操作：

.. code-block:: rust

    let va = VAddr::<Sv39>::new(0x12345);
    va.floor()  // 向下取整到页边界，得到 VPN
    va.ceil()   // 向上取整到页边界，得到 VPN
    va.offset() // 获取页内偏移（低 12 位）


AddressSpace 结构
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``kernel-vm`` 库提供了 ``AddressSpace`` 来管理地址空间：

.. code-block:: rust

    // kernel-vm/src/space/mod.rs

    pub struct AddressSpace<Meta: VmMeta, M: PageManager<Meta>> {
        /// 虚拟地址块列表，记录哪些范围被映射
        pub areas: Vec<Range<VPN<Meta>>>,
        /// 页管理器，负责分配物理页和管理页表
        page_manager: M,
    }

主要方法：

- ``new()``：创建新的地址空间（自动创建根页表）
- ``map_extern()``：将虚拟地址范围映射到已有的物理页
- ``map()``：分配新物理页并建立映射
- ``translate()``：将虚拟地址转换为物理地址
- ``root_ppn()``：获取根页表的物理页号


关键概念总结
------------------------------------------------------

.. list-table::
   :header-rows: 1

   * - 概念
     - 说明
   * - SV39
     - 39 位虚拟地址的分页模式
   * - VPN
     - 虚拟页号，27 位，用于页表查找
   * - PPN
     - 物理页号，44 位，指向物理页帧
   * - PTE
     - 页表项，包含 PPN 和标志位
   * - satp
     - 控制分页的 CSR，存储页表根节点地址
   * - 三级页表
     - SV39 使用三级页表进行地址转换

下一节我们将介绍如何分配物理页帧、建立页表映射。
