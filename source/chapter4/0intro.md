# 引言

## 本章导读

在上一章中，我们实现了多道程序系统，多个应用程序可以并发执行。然而，这些程序都运行在同一个物理地址空间中，任何一个程序都可以访问其他程序甚至内核的内存，这显然是不安全的。

本章的目标是实现 **虚拟内存机制**，为每个应用程序提供独立的地址空间。这是现代操作系统最核心的机制之一，它能够：

- **隔离性**：每个应用程序只能访问自己的地址空间，无法访问其他应用或内核的数据
- **安全性**：通过页表权限位实现内存保护，防止越权访问
- **灵活性**：支持更灵活的内存布局，应用程序可以使用连续的虚拟地址
- **防范侧信道攻击**：内核和应用使用独立的地址空间，可以防范 Meltdown 等漏洞

## 为什么需要虚拟内存？

让我们用一个简单的例子来说明：

在第三章中，如果应用程序 A 的代码段位于物理地址 `0x80400000`，那么它可以直接读取物理地址 `0x80200000` 处的内核代码！这是一个严重的安全隐患。

```
物理内存布局（第三章）：
+------------------+ 0x80200000
|   内核代码       |  <-- 任何应用都可以访问！
+------------------+ 0x80400000
|   应用 A         |
+------------------+ 0x80600000
|   应用 B         |  <-- 应用 A 也可以访问！
+------------------+
```

引入虚拟内存后，每个应用程序都有自己的 "虚拟世界"：

```
应用 A 的虚拟地址空间：        应用 B 的虚拟地址空间：
+------------------+          +------------------+
|   用户栈         |          |   用户栈         |
+------------------+          +------------------+
|     ...          |          |     ...          |
+------------------+          +------------------+
|   代码段         |          |   代码段         |
+------------------+ 0x10000  +------------------+ 0x10000

两个应用都认为自己的代码从 0x10000 开始，
但实际上它们被映射到不同的物理页面！
```

## 实践体验

本章应用运行起来效果与上一章基本一致，但底层实现已经完全不同——每个应用程序现在运行在独立的虚拟地址空间中。

在 qemu 模拟器上运行本章代码：

```bash
$ cargo qemu --ch 4
```

你会看到类似的输出：

```
[ INFO] .text ----> 0x80200000..0x80214000
[ INFO] .rodata --> 0x80214000..0x8021d000
[ INFO] .data ----> 0x8021d000..0x811a3fc8
[ INFO] .boot ----> 0x811a4000..0x811aa000
[ INFO] (heap) ---> 0x811aa000..0x81a00000

[ INFO] detect app[0]: 0x8021d080..0x80365718
[ INFO] process entry = 0x13ee6
...
Hello, world!
```

注意观察：
- 内核的各个段被映射到不同的虚拟地址范围
- 每个应用程序有自己的入口地址（`process entry`）
- 非法内存访问会触发页错误（Page Fault）而非直接崩溃

## 本章代码树

```
rCore-Tutorial-in-single-workspace/
├── ch4/
│   ├── Cargo.toml          # 项目配置文件
│   ├── build.rs            # 构建脚本
│   └── src/
│       ├── main.rs         # 内核主函数
│       └── process.rs      # 进程管理（新增）
├── kernel-vm/              # 虚拟内存管理库（新增）
│   └── src/
│       ├── lib.rs          # PageManager trait
│       └── space/          # AddressSpace 实现
├── kernel-context/         # 内核上下文管理库
│   └── src/
│       └── foreign/        # 跨地址空间的上下文切换（新增）
├── kernel-alloc/           # 内核堆分配器（新增）
│   └── src/
│       └── lib.rs          # 动态内存分配
├── linker/                 # 链接脚本和应用程序管理库
├── syscall/                # 系统调用库
└── console/                # 控制台库
```

## 与第三章的对比

| 特性 | 第三章 | 第四章 |
|------|--------|--------|
| 地址空间 | 所有任务共享物理地址空间 | 每个进程拥有独立的虚拟地址空间 |
| 数据结构 | `TaskControlBlock` | `Process` (含 `AddressSpace`) |
| 上下文 | `LocalContext` | `ForeignContext` (跨地址空间) |
| 内存保护 | 无 | 通过页表实现 |
| 地址转换 | 直接使用物理地址 | 通过 MMU 进行地址转换 |
| 应用加载 | 二进制数据直接执行 | 解析 ELF 文件建立映射 |
| 内存分配 | 固定栈数组 | 动态堆分配 |
| 系统调用 | 直接访问用户指针 | 需要地址翻译 |
| 安全性 | 弱 | 强，完全隔离 |

## 本章主要变化

1. **虚拟内存管理**：使用 `kernel-vm` 库实现 SV39 分页机制
2. **地址空间隔离**：内核和应用程序拥有独立的地址空间
3. **跨地址空间切换**：通过 `ForeignContext` 和传送门机制实现
4. **ELF 解析**：使用 `xmas-elf` 库解析应用程序，按段建立映射
5. **动态内存分配**：内核支持堆分配，可以使用 `Vec`、`Box` 等

## 关键概念预览

在深入代码之前，让我们先了解本章的核心概念：

- **虚拟地址 (VA)**：程序看到的地址，需要经过 MMU 转换
- **物理地址 (PA)**：实际的内存地址
- **页 (Page)**：虚拟地址空间的最小单位，通常 4KB
- **页帧 (Frame)**：物理内存的最小单位，与页大小相同
- **页表 (Page Table)**：虚拟页到物理页帧的映射关系
- **SV39**：RISC-V 64 位架构的 39 位虚拟地址分页模式
- **地址空间**：由页表定义的虚拟地址到物理地址的映射集合
- **传送门 (Portal)**：用于跨地址空间切换的特殊机制

本章内容较多，建议按顺序阅读，逐步理解虚拟内存的实现原理。
